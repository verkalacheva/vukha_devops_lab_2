
# Лабораторная 2

## Задание:
Написать два Dockerfile – плохой и хороший. Плохой должен запускаться и работать корректно, но в нём должно быть не менее 3 “bad practices”. В хорошем Dockerfile они должны быть исправлены. В Readme описать все плохие практики из кода Dockerfile и почему они плохие, как они были исправлены в хорошем  Dockerfile, а также две плохие практики по использованию этого контейнера
## Выполнение работы:

### 1. Теория. Docker и Dockerfile
Docker — это платформа, которая позволяет упаковать в контейнер приложение со всем окружением и зависимостями, а затем доставить и запустить его в целевой системе.

Контейнер Docker – это среда выполнения со всеми необходимыми компонентами, такими как код, зависимости и библиотеки, которые необходимы для запуска кода приложения без использования зависимостей хост-машины.

Образ Docker или образ контейнера – это отдельный исполняемый файл, используемый для создания контейнера. 

Dockerfile - набор инструкций и команд, которые будут автоматически выполнены для создания нового образа.

Проще говоря, докерфайл - это рецепт, по которому будет собираться образ. На примере создания образа игры MegaMario 1.7, мы внедрим определенные bad practices в Dockerfile и сравним сборку обычного и испорченного файлов.

---
### 2. Внедрение bad practices
1. **Bad practice. Разделение команд "apt-get update" и "apt-get install" в отдельные RUN**

Первой плохой практикой является разделение команд в директиве RUN. В хорошем файле мы соединяем команды "apt-get update" и "apt-get install", т.к. команда update имеет свой собственный кеш, и при вызове отдельно невозможно будет изменить версию устанавливаемых в команде install утилит без очистки кеша update. Чтобы избежать проблем, связанных с кешем, в хорошем файле объединяем эти две команды. В плохом файле каждая команда вызывается отдельным RUN-ом. 

 - **Плохой файл - каждая команда в отдельном RUN**

<image src="/images/bad_practice1(run).png" alt="">

 - **Хороший файл - несколько команд в одном RUN**

<image src="/images/good_practice1(run).png" alt="">

 2. **Bad practice. Отсутствие очистки кеша**

Docker работает поверх файловой системы overlayfs, которая позволяет накладывать несколько деревьев каталогов друг на друга. Образ состоит из неизменяемых слоев, каждый из которых добавляет/удаляет/изменяет файлы из предыдущего слоя. Таким образом, файлы на разных слоях образа могут дублироваться, занимая место в памяти. Поэтому в хорошем файле прописываем команду, удаляющую информацию о загруженных пакетах:
```
rm -rf /var/lib/apt/lists/*
```
В плохом варианте данную практику не используем.

- **Хороший файл - чистим кеш**

<image src="/images/good_practice2(remove).png" alt="">

3. **Bad practice. Распаковка архива внутри докерфайла**

В качестве третьей плохой практики реализуем в докерфайле распаковку zip архива с необходимыми файлами. Это плохо по многим причинам. Во-первых, контейнер распакует этот архив при запуске, это приведет к пустой трате времени. Во-вторых, образы Docker уже сжимаются, когда они хранятся в реестре и когда они загружаются в реестр или извлекаются из него, поэтому использовать архив для экономии места бессмысленно. В плохом файле распакуем zip архив, в хорошем используем сразу распакованную папку со всеми компонентами игры.

- **Плохой файл - ипсользование и распаковка архива**

<image src="/images/bad_practice3(unzip).png" alt="">

---

### 3. Сравнение времени сборки и занимаемого места двух докерфайлов

Для измерения времени сборки используем команду time.
```
time docker build -t mymario_image .
```
- **Время сборки плохого файла**
  
<image src="/images/bad_result.png" alt="Время сборки плохого файла">

- **Время сборки нормального файла**
  
<image src="/images/good_result.png" alt="Время сборки нормального файла">

Получили время сборки нормального файла - 2 минуты 5 секунд, плохого - 3 минуты, что дает нам разницу в 1.5 раза. Данное отличие несущественно, если нас интересует загрузка только одной игры, но в большой компании, когда в день необходимо собрать несколько сотен образов, такая разница в скорости имеет большое значение.

Для сравнения занимаемой памяти запустим команду docker images. Видим, что плохой файл весит 564 МБ, хороший 537 МБ, что подтверждает то, что нужно чистить кеш.
- **Плохой файл на 30 МБ больше**
  
<image src="/images/storage.png" alt="Занимаемое образами место">

---

### 4. Плохие практики по по использованию контейнера
- **Плохая практика 1. Запускать процессы от имени root**
По умолчанию docker-контейнеры запускаются с правами root. В современных условиях требование прав root может расцениваться как угроза и предоставляться не во всех средах. Для указания пользователя отличного от root, от имени которого будет запускаться контейнер, используется директива USER.
- **Плохая практика 2. Создавать образы из запущенных контейнеров**
Иначе говоря, лучше не применять команду docker commit для создания образа, поскольку такие образы не будут воспроизводимыми. Вместо нее можно использовать Dockerfile или другие инструменты S2I (source-to-image), которые обеспечивают воспроизводимость. Кроме того, в Dockerfile можно легко отследить изменения, если хранить его в репозитории исходных текстов (git).
